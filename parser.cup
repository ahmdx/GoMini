import java.io.*;
import java_cup.runtime.*;

// [] = ?
// {} = *				 -> _st
// () = grouping -> _grp


parser code {:
    // Connect this parser to a lexer!
    Lexer lexer;
    static String output;
    parser(Lexer lexer){ this.lexer=lexer; }

    static int lastTempVar = 0;
    static String newVar() {
      return "t" + lastTempVar++;
    }
:};

/* define how to connect to the scanner! */
init with {: :};
scan with {: return lexer.next_token(); :};


/* Terminals (tokens returned by the scanner). */
terminal String			ERROR;
terminal String			PACKAGE, IMPORT;
terminal String			IDENTIFIER;

terminal String			STRING_LIT, INT_LIT;

terminal String			FOR, CONST, VAR, IF, ELSE, SWITCH, CASE, FUNC, DEFAULT,
							TYPE, BREAK, RETURN, STRUCT;

terminal String			COLON, COLON_EQUAL;
terminal String			INCREMENT, DECREMENT;
terminal String			REL_OP, AND_OP, OR_OP;
terminal String			LESS_DASH, SHIFT_LEFT, SHIFT_RIGHT;
terminal String			DOT, COMMA, SEMI_COLON, PERCENT, EXCLAMATION, ASTRISK,
							AMBERSAND, BAR, SLASH, EQUAL, PLUS, MINUS, OPEN_PARAN,
							CLOSE_PARAN, OPEN_CURLY, CLOSE_CURLY, OPEN_SQUARE,
							CLOSE_SQUARE, CDOTS;

/* Non-terminals */
nonterminal String		source_file, import_decl_st;
nonterminal String		package_clause, package_name;
nonterminal String		import_decl, import_decl_grp, import_spec_st,
							import_spec, import_path;

nonterminal String		top_level_decl, top_level_decl_st;
nonterminal String		declaration;

nonterminal String 	const_decl, const_decl_grp, const_spec, const_spec_st;
nonterminal String 	var_decl, var_decl_grp, var_spec, var_spec_grp, var_spec_st,
							short_var_decl;
nonterminal String 	identifier_list, identifier_st;

nonterminal String		binary_op, add_op, mul_op, unary_op;

nonterminal String		type, type_name, type_lit;

nonterminal String 	function_decl, func_sign_grp, function_name, function, function_body,
							block;
nonterminal String 	function_type, signature, parameters, parameter_list,
							result, parameter_decl, parameter_decl_st;

nonterminal String 	method_decl, method_name, receiver;

nonterminal String 	expression, expression_list,
							expression_st, unary_expr, primary_expr, selector, arguments;
nonterminal String 	operand, literal, operand_name, qualified_ident;
nonterminal String 	basic_lit, function_lit;

/* Statement ********************************************************/
nonterminal String 	statement, statement_st, statement_list;
nonterminal String 	simple_stmt, expression_stmt, inc_dec_stmt,
							inc_dec_stmt_grp, assignment, assign_op;
nonterminal String 	return_stmt, break_stmt;
nonterminal String 	if_stmt, else_if_block_grp;
nonterminal String 	switch_stmt, expr_switch_stmt, expr_case_clause, expr_case_clause_st,
							expr_switch_case;
nonterminal String 	for_stmt, condition, for_clause,
							init_stmt, post_stmt;
/********************************************************************/

precedence left 	COMMA;
precedence right 	EQUAL;
precedence left 	OR_OP;
precedence left 	AND_OP;
precedence left 	BAR;
precedence left 	AMBERSAND;
precedence left 	REL_OP;
precedence left 	SHIFT_LEFT, SHIFT_RIGHT;
precedence left 	PLUS, MINUS;
precedence right 	PLUS, MINUS, EXCLAMATION, INCREMENT, DECREMENT;
precedence left 	ASTRISK, SLASH, PERCENT;
precedence left 	OPEN_PARAN, CLOSE_PARAN, DOT, INCREMENT, DECREMENT;

start with source_file;

/* The grammar */

/* Source file ******************************************************/
source_file 		::= package_clause import_decl_st top_level_decl_st:top
                    {:
                      parser.output = top;
                    :}
										| package_clause SEMI_COLON import_decl_st top_level_decl_st:top
                    {:
                      parser.output = top;
                    :}
										;
/********************************************************************/

/* Package declaration **********************************************/
package_clause ::= PACKAGE package_name;
package_name	 ::= IDENTIFIER;
/********************************************************************/

/* Import declaration ***********************************************/
import_decl 		 ::= IMPORT import_decl_grp;
import_decl_grp	 ::= import_spec
										 | OPEN_PARAN import_spec_st CLOSE_PARAN
										 ;
import_decl_st	::= import_decl import_decl_st
										| import_decl SEMI_COLON import_decl_st
										|
										;
import_spec 		 ::= DOT import_path
										 | package_name import_path
										 | import_path
										 ;
/* { ImportSpec[";"] } */
import_spec_st 	 ::= import_spec import_spec_st
										 | import_spec SEMI_COLON import_spec_st
										 |
										 ;
import_path 		 ::= STRING_LIT;
/********************************************************************/

/* Top Level Declaration ********************************************/

top_level_decl		::= declaration:d
                      {:
                        RESULT = d;
                      :}
											| function_decl:f
                      {:
                        RESULT = f;
                      :}
											| function_decl:f SEMI_COLON
                      {:
                        RESULT = f;
                      :}
											| method_decl:m
                      {:
                        RESULT = m;
                      :}
											| method_decl:m 	SEMI_COLON
                      {:
                        RESULT = m;
                      :}
											;
top_level_decl_st ::= top_level_decl:top top_level_decl_st:top_st
                      {:
                        RESULT = top + top_st;
                      :}
											|
											;

/* Declaration ******************************************************/
declaration 					::= const_decl:c 	SEMI_COLON
                          {:
                            RESULT = c;
                          :}
													| var_decl 	SEMI_COLON
													;

const_decl 						::= CONST const_decl_grp:c_grp
                          {:
                            RESULT = c_grp;
                          :};
const_decl_grp				::= const_spec:c
                          {:
                            RESULT = c;
                          :}
													| OPEN_PARAN const_spec_st:c_st CLOSE_PARAN
                          {:
                            RESULT = c_st;
                          :}
													;
const_spec 						::= IDENTIFIER:id
                          {:
                            RESULT = id;
                          :}
													| IDENTIFIER:id EQUAL expression:e
                          {:
                            RESULT = id + " = " + e;
                          :}
													| IDENTIFIER:id type EQUAL expression:e
                          {:
                            RESULT = id + " = " + e;
                          :}
													;
const_spec_st 				::= const_spec:c SEMI_COLON const_spec_st:c_st
                          {:
                            RESULT = c + c_st;
                          :}
													|
													;
var_decl 							::= VAR var_decl_grp;
var_decl_grp 					::= var_spec
													| OPEN_PARAN var_spec_st CLOSE_PARAN
													;
var_spec 							::= IDENTIFIER var_spec_grp;
var_spec_grp 					::= type
													| type EQUAL expression
													| EQUAL expression
													|
													;
var_spec_st 					::= var_spec SEMI_COLON var_spec_st
													|
													;
short_var_decl 				::= identifier_list COLON_EQUAL expression;
identifier_list 			::= IDENTIFIER identifier_st;
identifier_st 				::= COMMA IDENTIFIER identifier_st
													|
													;
/* Function *********************************************************/
function_decl 				::= FUNC function_name:name func_sign_grp:f_grp
                          {:
                            RESULT = "\n" + name + ":" + "\nbegin_func;" + f_grp + "\nend_func;";
                          :}
                          ;
func_sign_grp 				::= function:f
                          {:
                            RESULT = f;
                          :}
													| signature:s
                          {:
                            RESULT = s;
                          :}
													;
function_name 				::= IDENTIFIER:id
                          {:
                            RESULT = id;
                          :}
                          ;
function 							::= signature function_body:fb
                          {:
                            RESULT = fb;
                          :}
                          ;
function_body 				::= block:b
                          {:
                            RESULT = b;
                          :}
                          ;
/* Method ***********************************************************/
method_decl 					::= FUNC receiver method_name func_sign_grp
                          {:
                            System.out.println("METHO");
                          :}
                          ;
receiver 							::= parameters
                          {:
                            System.out.println("PARAMS");
                          :}
                          ;
method_name					 	::= IDENTIFIER:id
                          {:
                            System.out.println(id);
                          :}
                          ;
/* Block ************************************************************/
block 								::= OPEN_CURLY statement_list:st CLOSE_CURLY
                          {:
                            RESULT = st;
                          :}
                          ;
/* Statement ********************************************************/
statement 						::= declaration:d
                          {:
                            RESULT = "\n" + d;
                          :}
													| simple_stmt:s SEMI_COLON
                          {:
                            RESULT = "\n" + s;
                          :}
													| return_stmt:r SEMI_COLON
                          {:
                            RESULT = "\n" + r;
                          :}
													| break_stmt 	SEMI_COLON
													| block
													| block 			SEMI_COLON
													| if_stmt
													| if_stmt 		SEMI_COLON
													| switch_stmt
													| switch_stmt SEMI_COLON
													| for_stmt
													| for_stmt 		SEMI_COLON
													;
statement_list 				::= statement_st:st_st
                          {:
                            RESULT = st_st;
                          :}
                          ;
statement_st 					::= statement:st statement_st:st_st
                          {:
                            RESULT = st + st_st;
                          :}
													|
													;
simple_stmt 					::= expression_stmt:e
                          {:
                            System.out.println("EXPR");
                            RESULT = e;
                          :}
													| inc_dec_stmt
													| assignment
                          {:
                            System.out.println("ASSIGN");
                          :}
													| short_var_decl
                          {:
                            System.out.println("SH_VAR");
                          :}
													;
expression_stmt 			::= expression:e
                          {:
                            RESULT = e;
                          :}
                          ;
inc_dec_stmt 					::= expression inc_dec_stmt_grp;
inc_dec_stmt_grp			::= INCREMENT
													| DECREMENT
													;
/* Assignment *******************************************************/
assignment 						::= expression_list assign_op expression_list;
assign_op 						::= EQUAL
													| add_op EQUAL
													| mul_op EQUAL
													;
/* IF ELSE statement ************************************************/
if_stmt 							::= IF expression block
													| IF expression block ELSE else_if_block_grp
													| IF simple_stmt SEMI_COLON expression block
													| IF simple_stmt SEMI_COLON expression block ELSE else_if_block_grp
													;
else_if_block_grp 				::= if_stmt
													| block
													;
/* SWITCH statement *************************************************/
switch_stmt 					::= expr_switch_stmt;
// expr_switch_stmt 			::= SWITCH simple_stmt_scol_zone expression_zone OPEN_CURLY expr_case_clause_st CLOSE_CURLY;
expr_switch_stmt 			::= SWITCH OPEN_CURLY expr_case_clause_st CLOSE_CURLY
													| SWITCH expression OPEN_CURLY expr_case_clause_st CLOSE_CURLY
													| SWITCH simple_stmt SEMI_COLON OPEN_CURLY expr_case_clause_st CLOSE_CURLY
													| SWITCH simple_stmt SEMI_COLON expression OPEN_CURLY expr_case_clause_st CLOSE_CURLY
													;
expr_case_clause 			::= expr_switch_case COLON statement_list;
expr_case_clause_st 	::= expr_case_clause expr_case_clause_st
													|
													;
expr_switch_case 			::= CASE expression
													| DEFAULT
													;
/* FOR statement ****************************************************/
for_stmt 							::= FOR for_clause block
													;
condition 						::= expression;
// for_clause 						::= init_stmt_zone SEMI_COLON condition_zone SEMI_COLON post_stmt_zone;
for_clause 						::= init_stmt SEMI_COLON condition SEMI_COLON post_stmt
													;
init_stmt 						::= simple_stmt;
post_stmt 						::= simple_stmt;
/* BREAK statement **************************************************/
break_stmt 						::= BREAK;
/* RETURN statement *************************************************/
return_stmt 					::= RETURN:r
                          {:
                            RESULT = r;
                          :}
													| RETURN:r expression_list
                          {:
                            RESULT = r;
                          :}
													;
/********************************************************************/

/* Type *************************************************************/
type 					::= type_name | type_lit;
type_name 		::= IDENTIFIER;
type_lit			::= function_type
									;
/* Function *********************************************************/
function_type 				::= FUNC signature;
signature 						::= parameters
													| parameters result
													;
result 								::= parameters
													| OPEN_PARAN type CLOSE_PARAN
													;
parameters 						::= OPEN_PARAN CLOSE_PARAN
													| OPEN_PARAN parameter_list CLOSE_PARAN
													;
parameter_list 				::= parameter_decl parameter_decl_st;
parameter_decl  			::= identifier_list type
													| identifier_list CDOTS type
													;
parameter_decl_st			::= COMMA parameter_decl parameter_decl_st
													|
													;
/********************************************************************/

/* Expression *******************************************************/
expression		 				::= unary_expr:un_exp
                          {:
                            RESULT = un_exp;
                          :}
													| expression binary_op expression
													;
expression_list 			::= expression expression_st;
expression_st 				::= COMMA expression expression_st
													|
													;
unary_expr 						::= primary_expr:p_exp
                          {:
                            RESULT = p_exp;
                          :}
													| unary_op unary_expr
													;
primary_expr					::= operand:op
                          {:
                            RESULT = op;
                          :}
													| primary_expr selector
													| primary_expr:p arguments
                          {:
                            RESULT = parser.newVar() + " = " + "call " + p + "\n" + "pop_params;";
                          :}
													;
operand 							::= literal:lit
                          {:
                            RESULT = lit;
                          :}
													| operand_name:op
                          {:
                            RESULT = op;
                          :}
													| OPEN_PARAN expression CLOSE_PARAN
													;
literal 							::= basic_lit:b_lit
                          {:
                            RESULT = b_lit;
                          :}
													| function_lit
													;
basic_lit 						::= INT_LIT:i
                          {:
                            RESULT = i;
                          :}
													| STRING_LIT:s
                          {:
                            RESULT = s;
                          :}
													;
function_lit 					::= FUNC function;
selector 							::= DOT IDENTIFIER;
arguments 						::= OPEN_PARAN CLOSE_PARAN
                          {:
                            RESULT = "";
                          :}
													| OPEN_PARAN expression_list:el CLOSE_PARAN
                          {:
                          :}
													;
operand_name 					::= IDENTIFIER:id
                          {:
                            RESULT = id;
                          :}
													| qualified_ident:id
                          {:
                            RESULT = id;
                          :}
													;
qualified_ident 			::= DOT package_name DOT IDENTIFIER:id
                          {:
                            RESULT = id;
                          :}
                          ;
/********************************************************************/

/* Operators ********************************************************/
binary_op ::= OR_OP:op
              {:
                RESULT = op;
              :}
							| AND_OP:op
              {:
                RESULT = op;
              :}
							| REL_OP:op
              {:
                RESULT = op;
              :}
							| add_op:op
              {:
                RESULT = op;
              :}
							| mul_op:op
              {:
                RESULT = op;
              :}
							;
add_op ::=		PLUS:op
              {:
                RESULT = op;
              :}
							| MINUS:op
              {:
                RESULT = op;
              :}
							| BAR:op
              {:
                RESULT = op;
              :}
							;
mul_op ::=		ASTRISK:op
              {:
                RESULT = op;
              :}
							| SLASH:op
              {:
                RESULT = op;
              :}
							| PERCENT:op
              {:
                RESULT = op;
              :}
							| SHIFT_LEFT:op
              {:
                RESULT = op;
              :}
							| SHIFT_RIGHT:op
              {:
                RESULT = op;
              :}
							| AMBERSAND:op
              {:
                RESULT = op;
              :}
							;
unary_op ::=  PLUS:op
              {:
                RESULT = op;
              :}
							| MINUS:op
              {:
                RESULT = op;
              :}
							| EXCLAMATION:op
              {:
                RESULT = op;
              :}
							| ASTRISK:op
              {:
                RESULT = op;
              :}
							| AMBERSAND:op
              {:
                RESULT = op;
              :}
							| LESS_DASH:op
              {:
                RESULT = op;
              :}
							;
/********************************************************************/

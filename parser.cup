import java.io.*;
import java_cup.runtime.*;

// [] = ?				 -> _zone
// {} = *				 -> _st
// () = grouping -> _grp


parser code {:
    // Connect this parser to a lexer!
    Lexer lexer;
    parser(Lexer lexer){ this.lexer=lexer; }
:};

/* define how to connect to the scanner! */
init with {: :};
scan with {: return lexer.next_token(); :};


/* Terminals (tokens returned by the scanner). */
terminal			ERROR;
terminal			PACKAGE, IMPORT;
terminal			IDENTIFIER;

terminal			STRING_LIT, INT_LIT;

terminal			FOR, CONST, VAR, IF, ELSE, SWITCH, CASE, FUNC, DEFAULT, TYPE, BREAK,
					RETURN, STRUCT;

terminal			COLON, COLON_EQUAL;
terminal			INCREMENT, DECREMENT;
terminal			REL_OP, AND_OP, OR_OP;
terminal			LESS_DASH, SHIFT_LEFT, SHIFT_RIGHT;
terminal			DOT, COMMA, SEMI_COLON, PERCENT, EXCLAMATION, ASTRISK,
					AMBERSAND, BAR, SLASH, EQUAL, PLUS, MINUS, OPEN_PARAN, CLOSE_PARAN,
					OPEN_CURLY, CLOSE_CURLY, OPEN_SQUARE, CLOSE_SQUARE, CDOTS;

/* Non-terminals */
nonterminal		source_file, import_decl_st;
nonterminal		package_clause, package_name;
nonterminal		import_decl, import_decl_grp, import_spec_st,
							import_spec, dot_pckg_name, import_path;

nonterminal		top_level_decl, top_level_decl_st;
nonterminal		declaration, function_decl, method_decl;
nonterminal 	type_decl, type_decl_gr, type_spec, type_spec_st;

nonterminal 	const_decl, const_decl_grp, const_spec, const_spec_st,
							const_spec_help, const_spec_help_zone;
nonterminal 	var_decl, var_decl_grp, var_spec, var_spec_grp, var_spec_st,
							short_var_decl;
nonterminal 	identifier_list, identifier_st;
nonterminal 	eq_expression, eq_expression_zone;

nonterminal		binary_op, add_op, mul_op, unary_op;

nonterminal		type, type_zone, type_name, type_lit, type_type_scol, type_type_scol_zone;
nonterminal 	array_type, slice_type, element_type;
nonterminal 	struct_type, field_decl, field_decl_grp, field_decl_st;
nonterminal 	anonymous_field;
nonterminal		tag, tag_zone;
							
nonterminal 	array_length;

nonterminal 	function_type, signature, parameters, parameter_list,
							parameter_list_zone, result, result_zone,
							parameter_decl, parameter_decl_st, method_name;

nonterminal 	expression, expression_zone, expression_list, expression_st, unary_expr,
							primary_expr, selector, index, slice, arguments,
							type_expr_list, type_expr_list_zone;
nonterminal 	operand, literal, operand_name, method_expr, qualified_ident;
nonterminal 	basic_lit, composite_lit, function_lit;
nonterminal 	literal_type, literal_value;
nonterminal 	element_list, element_list_zone, keyed_element, keyed_element_st;
nonterminal 	key, key_col_zone, element, field_name;

nonterminal 	break_stmt;

nonterminal		asterisk_zone, semi_col_zone, cdots_zone;

precedence left COMMA;
precedence left AND_OP;
precedence left OR_OP;
precedence left AMBERSAND;
precedence left REL_OP;
precedence left BAR;
precedence left SHIFT_LEFT, SHIFT_RIGHT;
precedence left PLUS, MINUS;
precedence left ASTRISK, SLASH, PERCENT;
precedence right TYPE, IDENTIFIER;
precedence left INCREMENT, DECREMENT, OPEN_PARAN, CLOSE_PARAN, OPEN_CURLY, CLOSE_CURLY;

start with source_file;

/* The grammar */

/* Source file ******************************************************/
source_file 		::= package_clause semi_col_zone import_decl_st top_level_decl_st;
import_decl_st	::= import_decl_st import_decl semi_col_zone
										|
										;
/********************************************************************/

/* Package declaration **********************************************/
package_clause ::= PACKAGE package_name;
package_name	 ::= IDENTIFIER;
/********************************************************************/

/* Import declaration ***********************************************/
import_decl 		 ::= IMPORT import_decl_grp;
import_decl_grp	 ::= import_spec
										 | OPEN_PARAN import_spec_st CLOSE_PARAN
										 ;
/* { ImportSpec[";"] } */
import_spec_st 	 ::= import_spec_st import_spec semi_col_zone
										 |
										 ;
import_spec 		 ::= dot_pckg_name import_path;
dot_pckg_name		 ::= DOT
										 | package_name
										 |
										 ;
import_path 		 ::= STRING_LIT;
/********************************************************************/

/* Top Level Declaration ********************************************/

top_level_decl		::= declaration
											//| function_decl semi_col_zone
											//| method_decl semi_col_zone
											;
top_level_decl_st ::= top_level_decl top_level_decl_st
											|
											;

/* Declaration ******************************************************/
declaration 	::= const_decl SEMI_COLON
									| type_decl semi_col_zone
									| var_decl SEMI_COLON
									;

const_decl 						::= CONST const_decl_grp;
const_decl_grp				::= const_spec
													| OPEN_PARAN const_spec_st CLOSE_PARAN
													;
const_spec 						::= IDENTIFIER const_spec_help_zone;
const_spec_st 				::= const_spec SEMI_COLON const_spec_st
													|
													;
const_spec_help 			::= type_zone EQUAL expression;
const_spec_help_zone	::= const_spec_help
													|
													;
type_decl 						::= TYPE type_decl_gr;
type_decl_gr 					::= type_spec
													| OPEN_PARAN type_spec_st CLOSE_PARAN
													;
type_spec 						::= IDENTIFIER type;
type_spec_st 					::= type_spec SEMI_COLON type_spec_st
													|
													;
var_decl 							::= VAR var_decl_grp;
var_decl_grp 					::= var_spec
													| OPEN_PARAN var_spec_st CLOSE_PARAN
													;
var_spec 							::= IDENTIFIER var_spec_grp;
var_spec_grp 					::= type eq_expression_zone
													| eq_expression
													|
													;
eq_expression 				::= EQUAL expression;
eq_expression_zone 		::= eq_expression
													|
													;
var_spec_st 					::= var_spec SEMI_COLON var_spec_st
													|
													;
short_var_decl 				::= identifier_list COLON_EQUAL expression;
identifier_list 			::= IDENTIFIER identifier_st;
identifier_st 				::= COMMA IDENTIFIER identifier_st
													|
													;
/********************************************************************/

/* Type *************************************************************/
type 					::= type_name | type_lit;
type_zone 		::= type
									|
									;
type_name 		::= IDENTIFIER;
type_lit			::= array_type
									| struct_type
									| function_type
									| slice_type
									;
array_type				::= OPEN_SQUARE array_length CLOSE_SQUARE element_type;
array_length 			::= expression;
element_type			::= type;
slice_type 				::= OPEN_SQUARE CLOSE_SQUARE element_type;
struct_type 			::= STRUCT OPEN_CURLY field_decl_st CLOSE_CURLY;
field_decl 				::= field_decl_grp tag_zone;
field_decl_grp		::= identifier_list type
											| anonymous_field
											;
field_decl_st 		::= field_decl SEMI_COLON field_decl_st
											|
											;
anonymous_field 	::= asterisk_zone type_name;
tag 							::= STRING_LIT;
tag_zone 					::= tag
						 					|
						 					;
/* Function *********************************************************/
function_type 				::= FUNC signature;
signature 						::= parameters result_zone;
result 								::= parameters
													| OPEN_PARAN type CLOSE_PARAN
													;
result_zone 					::= result
													|
													;
parameters 						::= OPEN_PARAN parameter_list_zone CLOSE_PARAN;
parameter_list 				::= parameter_decl parameter_decl_st;
parameter_list_zone 	::= parameter_list
													|
													;
parameter_decl  			::= identifier_list cdots_zone type;
parameter_decl_st			::= COMMA parameter_decl_st
													|
													;
method_name					 	::= IDENTIFIER;
/********************************************************************/

/* Expression *******************************************************/
expression		 				::= unary_expr
													| expression binary_op expression
													;
expression_zone				::= expression
													|
													;
expression_list 			::= expression expression_st;
expression_st 				::= COMMA expression expression_st
													|
													;
unary_expr 						::= primary_expr
													| unary_op unary_expr
													;
primary_expr					::= operand
													| primary_expr selector
													| primary_expr index
													| primary_expr slice
													| primary_expr arguments 
													;
operand 							::= literal
													| operand_name
													| method_expr
													| OPEN_PARAN expression CLOSE_PARAN
													;
literal 							::= basic_lit
													| composite_lit
													| function_lit
													;
basic_lit 						::= INT_LIT
													| STRING_LIT
													;
composite_lit 				::= literal_type literal_value
													;
literal_type					::= struct_type
													| array_type
													| OPEN_SQUARE CDOTS CLOSE_SQUARE element_type
													| slice_type
													| TYPE type_name
													;
literal_value 				::= OPEN_CURLY element_list_zone CLOSE_CURLY;
element_list 					::= keyed_element keyed_element_st;
element_list_zone 		::= element_list
													|
													;
key 									::= field_name
													| literal_value
													;
key_col_zone 					::= key COLON
													|
													;
keyed_element 				::= key_col_zone element;
keyed_element_st 			::= COMMA keyed_element keyed_element_st
													|
													;
field_name 						::= IDENTIFIER;
element 							::= expression
													| literal_value
													;
selector 							::= DOT IDENTIFIER;
index									::= OPEN_SQUARE expression CLOSE_SQUARE;
slice 								::= OPEN_SQUARE expression_zone COLON expression_zone CLOSE_SQUARE
													| OPEN_SQUARE expression_zone COLON expression COLON expression CLOSE_SQUARE
													;
arguments 						::= OPEN_PARAN type_expr_list_zone CLOSE_PARAN;
type_type_scol 				::= TYPE type SEMI_COLON;
type_type_scol_zone 	::= type_type_scol
													|
													;
type_expr_list 				::= type_type_scol_zone expression_list;
type_expr_list_zone 	::= type_expr_list
													|
													;
operand_name 					::= IDENTIFIER
													| qualified_ident
													;
qualified_ident 			::= DOT package_name DOT IDENTIFIER;
/********************************************************************/

/* Operators ********************************************************/
binary_op ::= OR_OP
							| AND_OP
							| REL_OP
							| add_op
							| mul_op
							;
add_op ::=		PLUS
							| MINUS
							| BAR
							;
mul_op ::=		ASTRISK
							| SLASH
							| PERCENT
							| SHIFT_LEFT
							| SHIFT_RIGHT
							| AMBERSAND
							;
unary_op ::=  PLUS
							| MINUS
							| EXCLAMATION
							| ASTRISK
							| AMBERSAND
							| LESS_DASH
							;
/********************************************************************/

break_stmt 	::= BREAK;

asterisk_zone 	::= ASTRISK
								|
								;
semi_col_zone	  ::= SEMI_COLON
								|
								;
cdots_zone	 	  ::= CDOTS
								|
								;
